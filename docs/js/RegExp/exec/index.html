<h1>RegExp.prototype.exec()</h1><div><div></div></div><h2 id="summary"><a href="#summary" title="Permalink to Сводка">Сводка</a></h2><div><p>Метод <strong><code>exec()</code></strong> выполняет поиск сопоставления регулярного выражения в указанной строке. Возвращает массив с результатами или <a href="/js/null/"><code>null</code></a>.</p>

<p>Если целью выполнения является&nbsp;просто определить, проходит оно или нет, используйте метод <a href="/js/RegExp/test/"><code>RegExp.prototype.test()</code></a>, либо метод строки <a href="/js/String/search/"><code>String.prototype.search()</code></a>.</p></div><h2 id="syntax"><a href="#syntax" title="Permalink to Синтаксис">Синтаксис</a></h2><div><pre class="syntaxbox notranslate"><code><var>regexObj</var>.exec(<var>str</var>)</code></pre></div><h3 id="parameters"><a href="#parameters" title="Permalink to Параметры">Параметры</a></h3><div><dl>
 <dt><code>str</code></dt>
 <dd>Строка, с которой производится сопоставление регулярного выражения.</dd>
</dl></div><h3 id="returns"><a href="#returns" title="Permalink to Возвращаемое значение">Возвращаемое значение</a></h3><div><p>Если сопоставление успешно выполнилось, метод <code>exec()</code> возвращает массив и обновляет свойства объекта регулярного выражения. Возвращаемый массив в первом элементе содержит сопоставленный текст, а в последующих элементах&nbsp;— текст, захваченный при сопоставлении круглыми скобками.</p>

<p>Если сопоставление не удалось, метод <code>exec()</code> возвращает <a href="/js/null/"><code>null</code></a>.</p></div><h2 id="description"><a href="#description" title="Permalink to Описание">Описание</a></h2><div><p>Рассмотрим следующий пример:</p>

<pre class="brush: js notranslate"><code><span class="token comment">// Сопоставляется с фразой «кайф, сплющь», за которой следует слово «вши»,</span>
<span class="token comment">// игнорируя любые символы между ними. Запоминает слова «сплющь» и «вши».</span>
<span class="token comment">// Игнорирует регистр символов.</span>
<span class="token keyword">var</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">кайф,\s(сплющь).+?(вши)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'Эх, чужд кайф, сплющь объём вши, грызя цент.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>

<p>Таблица ниже показывает результаты выполнения данного примера:</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <td class="header">Объект</td>
   <td class="header">Свойство/Индекс</td>
   <td class="header">Описание</td>
   <td class="header">Пример</td>
  </tr>
  <tr>
   <td rowspan="4"><code>result</code></td>
   <td><code>[0]</code></td>
   <td>Все сопоставившиеся символы в строке.</td>
   <td><code>кайф, сплющь объём вши</code></td>
  </tr>
  <tr>
   <td><code>[1], ...[<em>n</em>]</code></td>
   <td>Сопоставившиеся подстроки в круглых скобках, если они присутствуют. Количество возможных подстрок ничем не ограничено.</td>
   <td><code>[1] = сплющь<br>
    [2] = вши</code></td>
  </tr>
  <tr>
   <td><code>index</code></td>
   <td>Индекс сопоставления в строке, начинается с нуля.</td>
   <td><code>9</code></td>
  </tr>
  <tr>
   <td><code>input</code></td>
   <td>Оригинальная строка.</td>
   <td><code>Эх, чужд кайф, сплющь объём вши, грызя цент.</code></td>
  </tr>
  <tr>
   <td rowspan="5"><code>re</code></td>
   <td><code>lastIndex</code></td>
   <td>Индекс, с которого начнётся следующая попытка сопоставления. Если отсутствует флаг <code>"g"</code>, остаётся равным нулю.</td>
   <td><code>31</code></td>
  </tr>
  <tr>
   <td><code>ignoreCase</code></td>
   <td>Указывает, что в регулярном выражении используется флаг игнорирования регистра <code>"i"</code>.</td>
   <td><code>true</code></td>
  </tr>
  <tr>
   <td><code>global</code></td>
   <td>Указывает, что в регулярном выражении используется флаг глобального сопоставления <code>"g"</code>.</td>
   <td><code>true</code></td>
  </tr>
  <tr>
   <td><code>multiline</code></td>
   <td>Указывает, что в регулярном выражении используется флаг сопоставления по нескольким строкам <code>"m"</code>.</td>
   <td><code>false</code></td>
  </tr>
  <tr>
   <td><code>source</code></td>
   <td>Текст шаблона регулярного выражения.</td>
   <td><code>кайф,\s(сплющь).+?(вши)</code></td>
  </tr>
 </tbody>
</table></div><h2 id="examples"><a href="#examples" title="Permalink to Примеры">Примеры</a></h2><div></div><h3 id="example_finding_successive_matches"><a href="#example_finding_successive_matches" title="Permalink to Пример: поиск последовательных сопоставлений">Пример: поиск последовательных сопоставлений</a></h3><div><p>Если ваше регулярное выражение использует флаг <code>"g"</code>, вы можете использовать метод <code>exec()</code> несколько раз для нахождения последовательных сопоставлений в одной и той же строке. Если вы сделаете это, поиск начнётся по подстроке строки <code>str</code>, начало которой определяется свойством <a href="/js/RegExp/lastIndex/"><code>lastIndex</code></a> регулярного выражения (метод <a href="/js/RegExp/test/"><code>test()</code></a> также увеличивает свойство <a href="/js/RegExp/lastIndex/"><code>lastIndex</code></a>). Например, предположим, что у вас есть следующий скрипт:</p>

<pre class="brush: js notranslate"><code><span class="token keyword">var</span> myRe <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">аб*</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'аббвгдеабж'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myArray<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>myArray <span class="token operator">=</span> myRe<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token string">'Найдено '</span> <span class="token operator">+</span> myArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'. '</span><span class="token punctuation">;</span>
  msg <span class="token operator">+=</span> <span class="token string">'Следующее сопоставление начнётся с позиции '</span> <span class="token operator">+</span> myRe<span class="token punctuation">.</span>lastIndex<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p>Этот скрипт выведет следующий текст:</p>

<pre class="brush: js notranslate"><code>Найдено абб<span class="token punctuation">.</span> Следующее сопоставление начнётся с позиции <span class="token number">3</span>
Найдено аб<span class="token punctuation">.</span> Следующее сопоставление начнётся с позиции <span class="token number">9</span>
</code></pre>

<p>Примечание: не помещайте литерал регулярного выражения (или конструктор <a href="/js/RegExp/"><code>RegExp</code></a>) внутрь условия <code>while</code>; это приведёт к бесконечному циклу, поскольку свойство <a href="/js/RegExp/lastIndex/"><code>lastIndex</code></a> будет сбрасываться в ноль на каждой итерации цикла. Также убедитесь, что установлен флаг глобального сопоставления, в противном случае цикл будет бесконечным.</p></div><h3 id="example_using_exec_with_regexp_literals"><a href="#example_using_exec_with_regexp_literals" title="Permalink to Пример: использование метода exec() вместе с литералами регулярного выражения">Пример: использование метода <code>exec()</code> вместе с литералами регулярного выражения</a></h3><div><p>Вы можете использовать метод <code>exec()</code> без создания объекта <a href="/js/RegExp/"><code>RegExp</code></a>:</p>

<pre class="brush: js notranslate"><code><span class="token keyword">var</span> matches <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(привет \S+)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">'Это привет миру!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>matches<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>

<p>Скрипт выведет в журнал строку «привет миру!».</p></div><h2 id="specifications"><a href="#specifications" title="Permalink to Спецификации">Спецификации</a></h2><div><table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Спецификация</th>
   <th scope="col">Статус</th>
   <th scope="col">Комментарии</th>
  </tr>
  <tr>
   <td>ECMAScript 3-е издание.</td>
   <td>Стандарт</td>
   <td>Изначальное определение. Реализована в JavaScript 1.2.</td>
  </tr>
  <tr>
   <td><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.10.6.21" hreflang="en" lang="en" class="external" rel=" noopener">ECMAScript 5.1 (ECMA-262)<br><small lang="ru">Определение 'RegExp.exec' в этой спецификации.</small></a></td>
   <td><span class="spec-standard">Стандарт</span></td>
   <td>&nbsp;</td>
  </tr>
  <tr>
   <td><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.exec" hreflang="en" lang="en" class="external" rel=" noopener">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="ru">Определение 'RegExp.exec' в этой спецификации.</small></a></td>
   <td><span class="spec-standard">Стандарт</span></td>
   <td>&nbsp;</td>
  </tr>
 </tbody>
</table></div><h2 id="browser_compatibility"><a href="#browser_compatibility" title="Permalink to Совместимость с браузерами">Совместимость с браузерами</a></h2><p>BCD tables only load in the browser</p><div><p></p><p></p></div><h2 id="see_also"><a href="#see_also" title="Permalink to Смотрите также">Смотрите также</a></h2><div><ul>
 <li>Глава про <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_Expressions">регулярные выражения</a> в <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide">руководстве по JavaScript</a></li>
 <li><a href="/js/RegExp/"><code>RegExp</code></a></li>
</ul></div>